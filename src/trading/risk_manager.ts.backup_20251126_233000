/**
 * é£é™©ç®¡ç†å™¨
 * è´Ÿè´£ä»“ä½ç®¡ç†ã€æ­¢æŸæ­¢ç›ˆã€ç†”æ–­æœºåˆ¶
 */

import {
  TradingSignal,
  SignalStrength,
  RiskConfig,
  PositionRecord,
  OrderRecord
} from '../types/trading_types';
import { logger } from '../utils/logger';

export class RiskManager {
  private config: RiskConfig;
  private daily_pnl: number = 0;
  private daily_pnl_reset_time: Date;
  private consecutive_losses: number = 0;
  private is_paused: boolean = false;
  private initial_balance: number = 0;  // è®°å½•åˆå§‹èµ„é‡‘

  constructor(config?: Partial<RiskConfig>) {
    // é»˜è®¤é£é™©é…ç½®
    this.config = {
      max_position_size_percent: 3,
      max_total_positions: 5,
      max_positions_per_symbol: 1,
      default_stop_loss_percent: 2,
      default_take_profit_percent: 5,
      use_trailing_stop: true,
      trailing_stop_callback_rate: 1,
      daily_loss_limit_percent: 5,
      consecutive_loss_limit: 3,
      pause_after_loss_limit: true,
      max_leverage: 3,
      leverage_by_signal_strength: {
        weak: 1,
        medium: 2,
        strong: 3
      },
      ...config
    };

    this.daily_pnl_reset_time = this.get_next_reset_time();
  }

  /**
   * æ£€æŸ¥æ˜¯å¦å¯ä»¥å¼€ä»“
   * @param signal äº¤æ˜“ä¿¡å·
   * @param current_positions å½“å‰æŒä»“åˆ—è¡¨
   * @param account_balance è´¦æˆ·ä½™é¢
   * @param current_time å›æµ‹æ¨¡å¼ä¸‹çš„å½“å‰æ—¶é—´ï¼ˆå¯é€‰ï¼‰
   * @returns æ˜¯å¦å…è®¸å¼€ä»“åŠåŸå› 
   */
  can_open_position(
    signal: TradingSignal,
    current_positions: PositionRecord[],
    account_balance: number,
    current_time?: Date
  ): {
    allowed: boolean;
    reason?: string;
    position_size?: number;
    leverage?: number;
  } {
    // 1. æ£€æŸ¥æ˜¯å¦æš‚åœäº¤æ˜“
    if (this.is_paused) {
      return {
        allowed: false,
        reason: 'Trading paused due to risk limits'
      };
    }

    // 2. æ£€æŸ¥æ¯æ—¥äºæŸé™åˆ¶
    const daily_check = this.check_daily_loss_limit(account_balance, current_time);
    if (!daily_check.allowed) {
      return daily_check;
    }

    // 3. æ£€æŸ¥è¿ç»­äºæŸé™åˆ¶
    const consecutive_check = this.check_consecutive_losses();
    if (!consecutive_check.allowed) {
      return consecutive_check;
    }

    // 4. æ£€æŸ¥æ€»æŒä»“æ•°é‡
    const open_positions = current_positions.filter(p => p.is_open);
    if (open_positions.length >= this.config.max_total_positions) {
      return {
        allowed: false,
        reason: `Maximum total positions (${this.config.max_total_positions}) reached`
      };
    }

    // 5. æ£€æŸ¥å•å¸ç§æŒä»“æ•°é‡
    const symbol_positions = open_positions.filter(p => p.symbol === signal.symbol);
    if (symbol_positions.length >= this.config.max_positions_per_symbol) {
      return {
        allowed: false,
        reason: `Maximum positions for ${signal.symbol} (${this.config.max_positions_per_symbol}) reached`
      };
    }

    // 6. è®¡ç®—ä»“ä½å¤§å°
    const position_size = this.calculate_position_size(signal, account_balance);

    // 7. ç¡®å®šæ æ†å€æ•°
    const leverage = this.determine_leverage(signal);

    logger.info(`[RiskManager] Position check passed for ${signal.symbol}: size=${position_size.toFixed(2)}, leverage=${leverage}x`);

    return {
      allowed: true,
      position_size,
      leverage
    };
  }

  /**
   * æ£€æŸ¥æ¯æ—¥äºæŸé™åˆ¶
   * @param account_balance å½“å‰è´¦æˆ·ä½™é¢
   * @param current_time å›æµ‹æ¨¡å¼ä¸‹çš„å½“å‰æ—¶é—´ï¼ˆå¯é€‰ï¼‰
   */
  private check_daily_loss_limit(
    account_balance: number,
    current_time?: Date
  ): {
    allowed: boolean;
    reason?: string;
  } {
    // ä½¿ç”¨å›æµ‹æ—¶é—´æˆ–ç³»ç»Ÿæ—¶é—´
    const check_time = current_time || new Date();

    // é‡ç½®æ¯æ—¥PnLï¼ˆå¦‚æœåˆ°äº†æ–°çš„ä¸€å¤©ï¼‰
    if (check_time >= this.daily_pnl_reset_time) {
      this.daily_pnl = 0;
      this.daily_pnl_reset_time = this.get_next_reset_time(check_time);
      logger.info('[RiskManager] Daily PnL reset');
    }

    // ğŸ”§ Bugä¿®å¤: ä½¿ç”¨åˆå§‹èµ„é‡‘è®¡ç®—é™åˆ¶ï¼Œè€Œä¸æ˜¯å½“å‰ä½™é¢
    const base_balance = this.initial_balance > 0 ? this.initial_balance : account_balance;
    const daily_loss_limit = base_balance * (this.config.daily_loss_limit_percent / 100);

    if (this.daily_pnl < -daily_loss_limit) {
      if (this.config.pause_after_loss_limit) {
        this.pause_trading();
      }

      return {
        allowed: false,
        reason: `Daily loss limit reached (${this.daily_pnl.toFixed(2)} / -${daily_loss_limit.toFixed(2)})`
      };
    }

    return { allowed: true };
  }

  /**
   * æ£€æŸ¥è¿ç»­äºæŸé™åˆ¶
   */
  private check_consecutive_losses(): {
    allowed: boolean;
    reason?: string;
  } {
    if (this.consecutive_losses >= this.config.consecutive_loss_limit) {
      if (this.config.pause_after_loss_limit) {
        this.pause_trading();
      }

      return {
        allowed: false,
        reason: `Consecutive loss limit reached (${this.consecutive_losses})`
      };
    }

    return { allowed: true };
  }

  /**
   * è®¾ç½®åˆå§‹èµ„é‡‘ï¼ˆç”¨äºè®¡ç®—å›ºå®šæ¯”ä¾‹ä¿è¯é‡‘ï¼‰
   */
  set_initial_balance(balance: number): void {
    this.initial_balance = balance;
    logger.info(`[RiskManager] Initial balance set to $${balance.toFixed(2)}`);
  }

  /**
   * åˆå§‹åŒ–å›æµ‹æ¨¡å¼ï¼ˆè®¾ç½®èµ·å§‹æ—¶é—´ç‚¹ï¼‰
   * @param backtest_start_time å›æµ‹å¼€å§‹æ—¶é—´
   */
  initialize_backtest_mode(backtest_start_time: Date): void {
    // é‡ç½®æ¯æ—¥PnL
    this.daily_pnl = 0;
    // è®¾ç½®ä¸‹ä¸€æ¬¡é‡ç½®æ—¶é—´ä¸ºå›æµ‹å¼€å§‹æ—¥æœŸçš„æ¬¡æ—¥UTC 0ç‚¹
    this.daily_pnl_reset_time = this.get_next_reset_time(backtest_start_time);
    logger.info(`[RiskManager] Backtest mode initialized, reset time: ${this.daily_pnl_reset_time.toISOString()}`);
  }

  /**
   * è®¡ç®—ä»“ä½å¤§å°ï¼ˆå›ºå®šæ¯”ä¾‹ä¿è¯é‡‘æ¨¡å¼ï¼‰
   *
   * å›ºå®šæ¯”ä¾‹æ¨¡å¼ï¼šæ¯ç¬”äº¤æ˜“ä½¿ç”¨åˆå§‹èµ„é‡‘çš„10%ä½œä¸ºä¿è¯é‡‘
   * margin = initial_balance * 10%
   * position_value = margin * leverage
   */
  private calculate_position_size(signal: TradingSignal, account_balance: number): number {
    // ä½¿ç”¨åˆå§‹èµ„é‡‘çš„10%ä½œä¸ºä¿è¯é‡‘
    const initial_balance = this.initial_balance || account_balance;
    const margin_percent = 0.1; // 10%
    const margin = initial_balance * margin_percent;
    const leverage = this.determine_leverage(signal);
    const position_value = margin * leverage;

    logger.debug(
      `[RiskManager] Fixed ratio mode: ` +
      `initial_balance=$${initial_balance.toFixed(2)}, ` +
      `margin=$${margin.toFixed(2)} (${(margin_percent * 100).toFixed(0)}%), ` +
      `leverage=${leverage}x, ` +
      `position_value=$${position_value.toFixed(2)}`
    );

    return position_value;
  }

  /**
   * ç¡®å®šæ æ†å€æ•°
   */
  private determine_leverage(signal: TradingSignal): number {
    let leverage: number;

    switch (signal.strength) {
      case SignalStrength.STRONG:
        leverage = this.config.leverage_by_signal_strength.strong;
        break;
      case SignalStrength.MEDIUM:
        leverage = this.config.leverage_by_signal_strength.medium;
        break;
      case SignalStrength.WEAK:
        leverage = this.config.leverage_by_signal_strength.weak;
        break;
      default:
        leverage = 1;
    }

    // ä¸è¶…è¿‡æœ€å¤§æ æ†
    return Math.min(leverage, this.config.max_leverage);
  }

  /**
   * è®¡ç®—æ­¢æŸæ­¢ç›ˆä»·æ ¼
   * å¼ºåˆ¶ä½¿ç”¨é…ç½®å€¼ï¼Œå¿½ç•¥ä¿¡å·çš„å»ºè®®ä»·æ ¼
   */
  calculate_stop_loss_take_profit(signal: TradingSignal): {
    stop_loss: number;
    take_profit: number;
  } {
    // å¼ºåˆ¶ä½¿ç”¨é…ç½®è®¡ç®—ï¼Œä¸ä½¿ç”¨ä¿¡å·çš„å»ºè®®ä»·æ ¼
    const entry_price = signal.entry_price || 0;
    if (entry_price === 0) {
      return { stop_loss: 0, take_profit: 0 };
    }

    const stop_loss_percent = this.config.default_stop_loss_percent / 100;
    const take_profit_percent = this.config.default_take_profit_percent / 100;

    let stop_loss: number;
    let take_profit: number;

    if (signal.direction === 'LONG') {
      stop_loss = entry_price * (1 - stop_loss_percent);
      take_profit = entry_price * (1 + take_profit_percent);
    } else {
      stop_loss = entry_price * (1 + stop_loss_percent);
      take_profit = entry_price * (1 - take_profit_percent);
    }

    return { stop_loss, take_profit };
  }

  /**
   * æ›´æ–°æŒä»“çš„ç§»åŠ¨æ­¢æŸ
   */
  update_trailing_stop(position: PositionRecord, current_price: number): number | null {
    if (!this.config.use_trailing_stop || !position.stop_loss_price) {
      return null;
    }

    const callback_rate = this.config.trailing_stop_callback_rate / 100;
    let new_stop_loss: number | null = null;

    if (position.side === 'LONG') {
      // å¤šå¤´ï¼šä»·æ ¼ä¸Šæ¶¨æ—¶æå‡æ­¢æŸ
      const price_from_entry = (current_price - position.entry_price) / position.entry_price;

      if (price_from_entry > 0.01) { // è‡³å°‘ç›ˆåˆ©1%æ‰å¯åŠ¨ç§»åŠ¨æ­¢æŸ
        const trailing_stop = current_price * (1 - callback_rate);

        if (trailing_stop > position.stop_loss_price) {
          new_stop_loss = trailing_stop;
        }
      }
    } else {
      // ç©ºå¤´ï¼šä»·æ ¼ä¸‹è·Œæ—¶é™ä½æ­¢æŸ
      const price_from_entry = (position.entry_price - current_price) / position.entry_price;

      if (price_from_entry > 0.01) {
        const trailing_stop = current_price * (1 + callback_rate);

        if (trailing_stop < position.stop_loss_price) {
          new_stop_loss = trailing_stop;
        }
      }
    }

    if (new_stop_loss) {
      logger.info(`[RiskManager] Trailing stop updated for ${position.symbol}: ${position.stop_loss_price.toFixed(2)} -> ${new_stop_loss.toFixed(2)}`);
    }

    return new_stop_loss;
  }

  /**
   * è®°å½•äº¤æ˜“ç»“æœï¼Œæ›´æ–°é£é™©çŠ¶æ€
   */
  record_trade_result(pnl: number, is_win: boolean): void {
    // æ›´æ–°æ¯æ—¥PnL
    this.daily_pnl += pnl;

    // æ›´æ–°è¿ç»­äºæŸè®¡æ•°
    if (is_win) {
      this.consecutive_losses = 0;
    } else {
      this.consecutive_losses++;
    }

    logger.info(`[RiskManager] Trade result: PnL=${pnl.toFixed(2)}, Daily PnL=${this.daily_pnl.toFixed(2)}, Consecutive losses=${this.consecutive_losses}`);
  }

  /**
   * æš‚åœäº¤æ˜“
   */
  pause_trading(): void {
    this.is_paused = true;
    logger.warn('[RiskManager] Trading paused due to risk limits');
  }

  /**
   * æ¢å¤äº¤æ˜“
   */
  resume_trading(): void {
    this.is_paused = false;
    this.consecutive_losses = 0;
    logger.info('[RiskManager] Trading resumed');
  }

  /**
   * é‡ç½®æ¯æ—¥ç»Ÿè®¡
   */
  reset_daily_stats(): void {
    this.daily_pnl = 0;
    this.daily_pnl_reset_time = this.get_next_reset_time();
    logger.info('[RiskManager] Daily stats reset');
  }

  /**
   * è·å–ä¸‹ä¸€æ¬¡é‡ç½®æ—¶é—´ï¼ˆUTC 0ç‚¹ï¼‰
   * @param base_time åŸºå‡†æ—¶é—´ï¼ˆå›æµ‹æ¨¡å¼ä½¿ç”¨ï¼Œå¯é€‰ï¼‰
   */
  private get_next_reset_time(base_time?: Date): Date {
    const now = base_time || new Date();
    const tomorrow = new Date(now);
    tomorrow.setUTCDate(tomorrow.getUTCDate() + 1);
    tomorrow.setUTCHours(0, 0, 0, 0);
    return tomorrow;
  }

  /**
   * è·å–å½“å‰é£é™©çŠ¶æ€
   */
  get_risk_status(): {
    is_paused: boolean;
    daily_pnl: number;
    consecutive_losses: number;
    next_reset_time: Date;
  } {
    return {
      is_paused: this.is_paused,
      daily_pnl: this.daily_pnl,
      consecutive_losses: this.consecutive_losses,
      next_reset_time: this.daily_pnl_reset_time
    };
  }

  /**
   * æ›´æ–°é£é™©é…ç½®
   */
  update_config(new_config: Partial<RiskConfig>): void {
    this.config = { ...this.config, ...new_config };
    logger.info('[RiskManager] Config updated');
  }

  /**
   * è·å–å½“å‰é…ç½®
   */
  get_config(): RiskConfig {
    return { ...this.config };
  }
}
